>回溯法（back tracking）（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。

回溯算法也叫试探法，它是一种系统地搜索问题的解的方法。

用回溯算法解决问题的一般步骤：

-  针对所给问题，定义问题的解空间，它至少包含问题的一个（最优）解。
-  确定易于搜索的解空间结构,使得能用回溯法方便地搜索整个解空间 。
-  以深度优先的方式搜索解空间，并且在搜索过程中用剪枝函数避免无效搜索。
确定了解空间的组织结构后，回溯法就从开始结点（根结点）出发，以深度优先的方式搜索整个解空间。这个开始结点就成为一个活结点，同时也成为当前的扩展结点。在当前的扩展结点处，搜索向纵深方向移至一个新结点。这个新结点就成为一个新的活结点，并成为当前扩展结点。如果在当前的扩展结点处不能再向纵深方向移动，则当前扩展结点就成为死结点。此时，应往回移动（回溯）至最近的一个活结点处，并使这个活结点成为当前的扩展结点。回溯法即以这种工作方式递归地在解空间中搜索，直至找到所要求的解或解空间中已没有活结点时为止。

#### 实例:八皇后问题
>八皇后问题是一个古老而著名的问题，是回溯算法的典型例题。该问题是十九世纪著名的数学家高斯1850年提出：在8X8格的国际象棋上摆放八个皇后（棋子），使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上。

这里简化一下，用四皇后图来表示，1表示可以放置皇后的位置,0表示不可以。
- 第一步:第一行第一列放置第一个皇后
```
  Q 0 0 0
  0 0 1 1
  0 1 0 1
  0 1 1 0
```
- 第二步:第二行的皇后只能放在第三格或第四格，比方我们放第三格，则：
```
  Q 0 0 0
  0 0 Q 0
  0 0 0 0
  0 1 0 0
```

- 第三步:从上面第二步可以出第三行没有地方可以放置皇后，所以第二步失败，把第二个皇后更改位置，放置在第二行第四列
```
  Q 0 0 0
  0 0 0 Q
  0 1 0 0
  0 0 1 0
```
- 第四步:虽然更改位置后第三行能够放置皇后了，但是第四行却不行了(上图的第四行可以放置的1是相对于第二行的皇后来的),所以向上回溯第二行，但是第二行也没有别的位置放了，继续回溯到第一行，于是第一个皇后改变位置到第二行
```
  0 Q 0 0
  0 0 0 1
  1 0 1 0
  1 0 1 1
```
这就是回溯算法的精髓，虽然没有最终把问题解决，但是可以剧透一波，就是根据这个算法，最终能够把四位皇后放在4x4的棋盘里。也能用同样的方法解决了八皇后问题。下面我们用代码解决八皇后问题。
```
    static final int QueenNum = 5;
    int Queen[] = new int[QueenNum];
    
    public boolean isOK(int col, int row) {
        for (int i = 0; i < row; i++) {
            int queenCol = Queen[i];
            int span = row - i;
            if (col == queenCol || (col == queenCol + span) || (col == queenCol - span)) {
                return false;
            }
        }
        return true;
    }
```
用一個Queen数组来存储皇后的位置，下标为行数，值为列数，比如Queen[1]=5就表示第二行的皇后在第六列
上述代码是输入一个位置的坐标，判断这个位置和前面的皇后位置规则是否存在冲突
```
    private void start() {
        Queen[0] = -1;
        int row = 0;
        int col = 0;
        int count = 0;
        while (true) {
            for (col = Queen[row] + 1; col < QueenNum; col++) {
                if (isOK(col, row)) {
                    break;
                }
            }
            if (col >= QueenNum) {//如果找到的列大于棋盘的范围
                //行为0时退出循环，不为0时则表示这一行不存在皇后，返回上一行找下一个皇后
                if (row == 0) {
                    break;
                } else {
                    Queen[row] = -1;
                    row--;
                }
            } else {
                Queen[row] = col;
                row++;
                if (row < QueenNum) {
                    Queen[row] = -1;
                } else {
                    count++;
                    print(count);
                    row--;
                }
            }
        }
    }

```
上面为主要代码，如果找到了符合规则的皇后，那么行数加一然后找寻下一行的皇后，如果找寻到了一个解法，同样行数减一去寻找下一个解法。
具体详情看 [NQueen.java](../../leetCode/me/verzqli/leetcode/Algorithm/NQueen)